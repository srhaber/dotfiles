#!/usr/bin/env bash
#
# worktree - Manage git worktrees for feature branch development
#
# Worktree Structure:
# - Main repo: Current directory (stays on main)
# - Worktrees: ../<repo-name>-worktrees/<branch-name>
# - Branch naming: Always use shaun/<feature> prefix
# - Directory naming: Use <feature> only (no username prefix)

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
error() {
    echo -e "${RED}Error: $*${NC}" >&2
    exit 1
}

warning() {
    echo -e "${YELLOW}Warning: $*${NC}" >&2
}

success() {
    echo -e "${GREEN}$*${NC}"
}

info() {
    echo -e "${BLUE}$*${NC}"
}

get_repo_name() {
    basename "$(git rev-parse --show-toplevel)"
}

get_worktree_parent() {
    local repo_name
    repo_name=$(get_repo_name)
    echo "$(git rev-parse --show-toplevel)/../${repo_name}-worktrees"
}

normalize_branch_name() {
    local branch="$1"
    # Add shaun/ prefix if not present
    if [[ ! "$branch" =~ ^shaun/ ]]; then
        echo "shaun/${branch}"
    else
        echo "$branch"
    fi
}

get_feature_name() {
    local branch="$1"
    # Strip shaun/ prefix to get directory name
    echo "${branch#shaun/}"
}

show_help() {
    local repo_name
    repo_name=$(get_repo_name 2>/dev/null || echo "your-repo")

    cat <<EOF
Git Worktree Manager

Commands:
  create <feature>   Create new worktree for shaun/<feature>
  list               Show all active worktrees
  remove <feature>   Remove worktree and optionally delete branch
  switch <feature>   Generate cd command to navigate to worktree
  clean              Find and remove unused worktrees/branches
  prune              Prune stale worktree references
  help               Show this help message

Examples:
  worktree create feature-fixes
  worktree list
  worktree clean
  worktree switch feature-fixes

Current location: $(pwd) (main branch)
Worktree location: ../${repo_name}-worktrees/<feature>
EOF
}

cmd_create() {
    local feature="$1"
    [[ -z "$feature" ]] && error "Feature name required. Usage: worktree create <feature>"

    local repo_name branch_name feature_name worktree_parent worktree_path
    repo_name=$(get_repo_name)
    branch_name=$(normalize_branch_name "$feature")
    feature_name=$(get_feature_name "$branch_name")
    worktree_parent=$(get_worktree_parent)
    worktree_path="${worktree_parent}/${feature_name}"

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        error "Worktree already exists at: $worktree_path"
    fi

    info "Fetching remote branches..."
    git fetch

    # Create parent directory if needed
    mkdir -p "$worktree_parent"

    # Check if branch exists remotely
    if git branch -r | grep -qw "origin/${branch_name}"; then
        info "Checking out existing remote branch: origin/${branch_name}"
        git worktree add "$worktree_path" "origin/${branch_name}"
    else
        info "Creating new branch: ${branch_name}"
        git worktree add -b "$branch_name" "$worktree_path"
    fi

    success "✓ Worktree created successfully!"
    echo
    info "To switch to the worktree, run:"
    echo "  cd $worktree_path"
}

cmd_list() {
    info "Active worktrees:"
    echo
    git worktree list
}

cmd_remove() {
    local feature="$1"
    [[ -z "$feature" ]] && error "Feature name required. Usage: worktree remove <feature>"

    local repo_name branch_name feature_name worktree_parent worktree_path
    repo_name=$(get_repo_name)
    branch_name=$(normalize_branch_name "$feature")
    feature_name=$(get_feature_name "$branch_name")
    worktree_parent=$(get_worktree_parent)
    worktree_path="${worktree_parent}/${feature_name}"

    # Check if worktree exists
    if [[ ! -d "$worktree_path" ]]; then
        error "Worktree not found at: $worktree_path"
    fi

    # Check for uncommitted changes
    if [[ -n "$(git -C "$worktree_path" status --short)" ]]; then
        warning "Worktree has uncommitted changes!"
        git -C "$worktree_path" status --short
        echo
        read -rp "Continue with removal? [y/N] " response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Aborted."
            exit 0
        fi
    fi

    info "Removing worktree..."
    git worktree remove "$worktree_path"
    git worktree prune

    success "✓ Worktree removed: $worktree_path"

    # Ask about deleting the branch
    echo
    read -rp "Delete branch ${branch_name}? [y/N] " response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        git branch -d "$branch_name" 2>/dev/null || {
            warning "Branch has unmerged commits. Use -D to force delete."
            read -rp "Force delete? [y/N] " force_response
            if [[ "$force_response" =~ ^[Yy]$ ]]; then
                git branch -D "$branch_name"
                success "✓ Branch deleted: $branch_name"
            fi
        }
    fi
}

cmd_prune() {
    info "Pruning stale worktree references..."
    git worktree prune -v
    echo

    # Find and remove local branches with deleted remotes
    info "Checking for branches with deleted remotes..."
    local gone_branches=()
    while IFS= read -r line; do
        local branch
        branch=$(echo "$line" | awk '{print $1}')
        [[ -z "$branch" ]] && continue
        gone_branches+=("$branch")
    done < <(git branch -vv | grep ': gone]' | awk '{print $1}')

    if [[ ${#gone_branches[@]} -gt 0 ]]; then
        echo
        echo "Found ${#gone_branches[@]} local branch(es) with deleted remotes:"
        for branch in "${gone_branches[@]}"; do
            echo "  - $branch"
        done
        echo

        read -rp "Delete these branches? [y/N] " response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            for branch in "${gone_branches[@]}"; do
                # Use -D to force delete since remote is already gone
                if git branch -D "$branch" 2>/dev/null; then
                    success "  ✓ Deleted $branch"
                else
                    warning "  ✗ Failed to delete $branch"
                fi
            done
        else
            echo "Skipped branch deletion"
        fi
    else
        success "✓ No branches with deleted remotes found"
    fi

    echo
    cmd_list
}

cmd_switch() {
    local feature="$1"
    [[ -z "$feature" ]] && error "Feature name required. Usage: worktree switch <feature>"

    local repo_name branch_name feature_name worktree_parent worktree_path
    repo_name=$(get_repo_name)
    branch_name=$(normalize_branch_name "$feature")
    feature_name=$(get_feature_name "$branch_name")
    worktree_parent=$(get_worktree_parent)
    worktree_path="${worktree_parent}/${feature_name}"

    if [[ ! -d "$worktree_path" ]]; then
        error "Worktree not found at: $worktree_path"
    fi

    echo "cd $worktree_path"
    echo
    info "Tip: Copy and paste the command above"
}

cmd_clean() {
    info "Analyzing worktrees and branches..."
    echo

    # Fetch and prune
    git fetch --prune

    local repo_name worktree_parent
    repo_name=$(get_repo_name)
    worktree_parent=$(get_worktree_parent)

    # Get all worktrees (excluding main)
    local worktrees=()
    local current_path=""
    local current_branch=""

    while IFS= read -r line; do
        if [[ "$line" =~ ^worktree\ (.+)$ ]]; then
            current_path="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^branch\ refs/heads/(.+)$ ]]; then
            current_branch="${BASH_REMATCH[1]}"

            # Skip main directory
            if [[ "$current_path" != "$(git rev-parse --show-toplevel)" ]]; then
                worktrees+=("$current_path|$current_branch")
            fi

            # Reset for next worktree
            current_path=""
            current_branch=""
        fi
    done < <(git worktree list --porcelain)

    # Find merged branches
    local merged_branches=()
    while IFS= read -r branch; do
        branch=$(echo "$branch" | xargs) # trim whitespace
        [[ "$branch" == "main" || "$branch" == "master" ]] && continue
        merged_branches+=("$branch")
    done < <(git branch --merged main 2>/dev/null || git branch --merged master 2>/dev/null || true)

    # Find branches with deleted remotes (shaun/* branches only)
    # This catches both:
    # 1. Manually deleted remote branches
    # 2. Branches merged via rebase/squash (GitHub deletes remote after merge)
    local orphaned_branches=()
    while IFS= read -r line; do
        # Parse git branch -vv output: "* branch  hash [tracking: gone]"
        # Remove leading markers (* or +) and whitespace, then extract branch name
        local branch
        branch=$(echo "$line" | sed 's/^[* +]*//' | awk '{print $1}')
        [[ ! "$branch" =~ ^shaun/ ]] && continue
        [[ "$branch" == "main" || "$branch" == "master" ]] && continue

        # Check if tracking branch is marked as "gone" or doesn't exist
        if echo "$line" | grep -q "gone]" || ! git branch -r | grep -qw "origin/${branch}"; then
            orphaned_branches+=("$branch")
        fi
    done < <(git branch -vv)

    # Categorize worktrees
    local worktrees_to_remove=()
    local reasons=()

    # Only process if there are worktrees to check
    if [[ ${#worktrees[@]} -gt 0 ]]; then
        for wt_entry in "${worktrees[@]}"; do
            local wt_path wt_branch
            IFS='|' read -r wt_path wt_branch <<< "$wt_entry"

            local reason=""

            # Check if branch is merged
            if [[ ${#merged_branches[@]} -gt 0 ]]; then
                for merged in "${merged_branches[@]}"; do
                    if [[ "$wt_branch" == "$merged" ]]; then
                        reason="merged into main"
                        break
                    fi
                done
            fi

            # Check if remote was deleted
            if [[ -z "$reason" && ${#orphaned_branches[@]} -gt 0 ]]; then
                for orphaned in "${orphaned_branches[@]}"; do
                    if [[ "$wt_branch" == "$orphaned" ]]; then
                        reason="remote branch deleted"
                        break
                    fi
                done
            fi

            if [[ -n "$reason" ]]; then
                worktrees_to_remove+=("$wt_path|$wt_branch")
                reasons+=("$reason")
            fi
        done
    fi

    # Display findings
    if [[ ${#worktrees_to_remove[@]} -eq 0 ]]; then
        success "✓ No worktrees need cleanup"
        return 0
    fi

    echo "Found ${#worktrees_to_remove[@]} worktree(s) to clean up:"
    echo

    for i in "${!worktrees_to_remove[@]}"; do
        local wt_entry="${worktrees_to_remove[$i]}"
        local reason="${reasons[$i]}"
        IFS='|' read -r wt_path wt_branch <<< "$wt_entry"

        echo "$((i+1)). $wt_branch"
        echo "   Path: $wt_path"
        echo "   Reason: $reason"

        # Check for uncommitted changes
        if [[ -n "$(git -C "$wt_path" status --short 2>/dev/null)" ]]; then
            warning "   ⚠ Has uncommitted changes"
        fi
        echo
    done

    # Prompt for action
    cat <<EOF
What would you like to do?
1) Remove all worktrees and delete branches
2) Remove all worktrees only (keep branches)
3) Cancel

EOF
    read -rp "Choice [1-3]: " choice

    case "$choice" in
        1)
            info "Removing worktrees and deleting branches..."
            for wt_entry in "${worktrees_to_remove[@]}"; do
                IFS='|' read -r wt_path wt_branch <<< "$wt_entry"
                echo "  - Removing $wt_branch..."
                git worktree remove "$wt_path" --force 2>/dev/null || true
                git branch -D "$wt_branch" 2>/dev/null || true
            done
            git worktree prune
            success "✓ Cleanup complete"
            ;;
        2)
            info "Removing worktrees only..."
            for wt_entry in "${worktrees_to_remove[@]}"; do
                IFS='|' read -r wt_path wt_branch <<< "$wt_entry"
                echo "  - Removing worktree for $wt_branch..."
                git worktree remove "$wt_path" --force 2>/dev/null || true
            done
            git worktree prune
            success "✓ Cleanup complete (branches preserved)"
            ;;
        *)
            echo "Cancelled"
            exit 0
            ;;
    esac
}

# Main command dispatcher
main() {
    # Check if we're in a git repo
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not in a git repository"
    fi

    local subcommand="${1:-help}"
    shift || true

    case "$subcommand" in
        create)
            cmd_create "$@"
            ;;
        list|ls)
            cmd_list
            ;;
        remove|rm)
            cmd_remove "$@"
            ;;
        prune)
            cmd_prune
            ;;
        switch|sw)
            cmd_switch "$@"
            ;;
        clean)
            cmd_clean
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            error "Unknown command: $subcommand\n\nRun 'worktree help' for usage."
            ;;
    esac
}

main "$@"
