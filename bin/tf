#!/usr/bin/env bash
#
# tf - Terraform/Terragrunt wrapper with enhanced plan/apply workflow
#
# Usage:
#   tf plan [args]   - Save plan to file with timestamp
#   tf apply [args]  - Apply most recent saved plan (auto-cleans old plans >1 day)
#   tf show [file]   - Show latest plan, specific plan file, or pass through to terraform show
#   tf summary       - Show high-level summary of plan changes
#   tf list          - List saved plan files
#   tf clean         - Remove old plan files
#   tf <cmd> [args]  - Pass through to terraform/terragrunt
#
# Environment:
#   USE_TERRAGRUNT=1  - Force use of terragrunt even if not auto-detected

set -euo pipefail

# Determine which command to use: terragrunt or terraform
# Priority: USE_TERRAGRUNT env var > terragrunt.hcl exists > terragrunt available > terraform
determine_tf_cmd() {
    # If USE_TERRAGRUNT is explicitly set
    if [[ -n "${USE_TERRAGRUNT:-}" ]]; then
        if command -v terragrunt &>/dev/null; then
            echo "terragrunt"
        else
            echo "terraform"
            echo "Warning: USE_TERRAGRUNT set but terragrunt not found, falling back to terraform" >&2
        fi
        return
    fi

    # Auto-detect: if terragrunt.hcl exists in current dir, use terragrunt
    if [[ -f "terragrunt.hcl" ]] && command -v terragrunt &>/dev/null; then
        echo "terragrunt"
        return
    fi

    # Default to terraform
    echo "terraform"
}

TF_CMD=$(determine_tf_cmd)

# Terragrunt: add --log-format bare for clean output (no timestamps/prefixes)
if [[ "$TF_CMD" == "terragrunt" ]]; then
    TF_CMD="terragrunt --log-format bare"
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Plan storage directory (relative to current dir)
PLANS_DIR=".terraform/plans"

# Helper functions
error() {
    echo -e "${RED}Error: $*${NC}" >&2
    exit 1
}

warning() {
    echo -e "${YELLOW}Warning: $*${NC}" >&2
}

success() {
    echo -e "${GREEN}$*${NC}"
}

info() {
    echo -e "${BLUE}$*${NC}"
}

# Ensure we're in a terraform directory
check_terraform_dir() {
    if ! ls *.tf &>/dev/null && [[ ! -d ".terraform" ]] && [[ ! -f "terragrunt.hcl" ]]; then
        warning "Not in a terraform directory (no .tf files, .terraform dir, or terragrunt.hcl found)"
    fi
}

# Get the most recent plan file
get_latest_plan() {
    if [[ ! -d "$PLANS_DIR" ]]; then
        return 1
    fi

    local latest
    latest=$(find "$PLANS_DIR" -name "*.tfplan" -type f 2>/dev/null | sort -r | head -1)

    if [[ -z "$latest" ]]; then
        return 1
    fi

    echo "$latest"
}

# Enhanced plan command
cmd_plan() {
    check_terraform_dir

    # Create plans directory if it doesn't exist
    mkdir -p "$PLANS_DIR"

    # Generate plan filename with timestamp
    local timestamp plan_file
    timestamp=$(date +%Y%m%d-%H%M%S)
    plan_file="${PLANS_DIR}/plan-${timestamp}.tfplan"

    info "Running $TF_CMD plan and saving to: $plan_file"
    echo

    # Run terraform plan with -out flag
    if command $TF_CMD plan -out="$plan_file" "$@"; then
        echo
        success "✓ Plan saved to: $plan_file"

        # Create/update symlink to latest plan
        local latest_link="${PLANS_DIR}/latest.tfplan"
        ln -sf "$(basename "$plan_file")" "$latest_link"

        info "Run 'tf apply' to apply this plan"
    else
        # Clean up empty plan file if command failed
        [[ -f "$plan_file" ]] && rm -f "$plan_file"
        exit 1
    fi
}

# Enhanced apply command
cmd_apply() {
    check_terraform_dir

    # Check if user provided arguments (plan file or terraform args)
    if [[ $# -gt 0 ]]; then
        # If user specified arguments, pass through
        info "Running $TF_CMD apply with provided arguments..."
        command $TF_CMD apply "$@"
        return $?
    fi

    # Try to get the latest plan file
    local latest_plan
    if latest_plan=$(get_latest_plan); then
        local plan_name
        plan_name=$(basename "$latest_plan")

        info "Applying saved plan: $plan_name"
        echo

        if command $TF_CMD apply "$latest_plan"; then
            success "✓ Plan applied successfully"

            # Auto-clean old plan files (older than 1 day)
            local old_plans
            old_plans=$(find "$PLANS_DIR" -name "*.tfplan" -type f -mtime +1 2>/dev/null || true)

            if [[ -n "$old_plans" ]]; then
                local count
                count=$(echo "$old_plans" | wc -l | xargs)

                while IFS= read -r old_plan; do
                    rm -f "$old_plan"
                done <<< "$old_plans"

                info "✓ Cleaned up $count old plan file(s) (>1 day old)"
            fi
        else
            exit 1
        fi
    else
        # No saved plan found, run normal apply
        info "No saved plan found. Running $TF_CMD apply..."
        echo
        command $TF_CMD apply
    fi
}

# List saved plans
cmd_list() {
    local names_only=false

    # Check for flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--names-only)
                names_only=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ ! -d "$PLANS_DIR" ]]; then
        if [[ "$names_only" == false ]]; then
            info "No plans directory found"
        fi
        return 0
    fi

    local plans
    plans=$(find "$PLANS_DIR" -name "*.tfplan" -type f 2>/dev/null | sort -r)

    if [[ -z "$plans" ]]; then
        if [[ "$names_only" == false ]]; then
            info "No saved plans found"
        fi
        return 0
    fi

    if [[ "$names_only" == true ]]; then
        # Condensed output: just plan names
        while IFS= read -r plan; do
            basename "$plan"
        done <<< "$plans"
    else
        # Detailed output
        info "Saved plans:"
        echo

        while IFS= read -r plan; do
            local plan_name plan_size plan_date
            plan_name=$(basename "$plan")
            plan_size=$(du -h "$plan" | cut -f1)
            plan_date=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$plan" 2>/dev/null || stat -c "%y" "$plan" 2>/dev/null | cut -d'.' -f1)

            echo -e "  ${CYAN}${plan_name}${NC}"
            echo "    Size: $plan_size"
            echo "    Created: $plan_date"
            echo "    Path: $plan"
            echo
        done <<< "$plans"
    fi
}

# Compare plans
cmd_diff() {
    check_terraform_dir

    local plan1 plan2

    if [[ $# -eq 0 ]]; then
        # No args: compare latest two plans
        local plans
        plans=$(find "$PLANS_DIR" -name "*.tfplan" -type f 2>/dev/null | sort -r | head -2)

        local plan_count
        plan_count=$(echo "$plans" | wc -l | xargs)

        if [[ $plan_count -lt 2 ]]; then
            error "Need at least 2 plans to compare. Found: $plan_count"
        fi

        plan1=$(echo "$plans" | sed -n 1p)
        plan2=$(echo "$plans" | sed -n 2p)

    elif [[ $# -eq 1 ]]; then
        # One arg: compare specified plan to previous plan
        if [[ -f "$1" ]]; then
            plan1="$1"
        elif [[ -f "${PLANS_DIR}/$1" ]]; then
            plan1="${PLANS_DIR}/$1"
        else
            error "Plan file not found: $1"
        fi

        # Find the plan created before plan1
        local plan1_time
        plan1_time=$(stat -f "%m" "$plan1" 2>/dev/null || stat -c "%Y" "$plan1" 2>/dev/null)

        plan2=$(find "$PLANS_DIR" -name "*.tfplan" -type f 2>/dev/null | while read -r p; do
            local p_time
            p_time=$(stat -f "%m" "$p" 2>/dev/null || stat -c "%Y" "$p" 2>/dev/null)
            if [[ "$p_time" -lt "$plan1_time" ]]; then
                echo "$p_time $p"
            fi
        done | sort -rn | head -1 | cut -d' ' -f2)

        if [[ -z "$plan2" ]]; then
            error "No previous plan found to compare with"
        fi

    elif [[ $# -eq 2 ]]; then
        # Two args: compare the two specified plans
        if [[ -f "$1" ]]; then
            plan1="$1"
        elif [[ -f "${PLANS_DIR}/$1" ]]; then
            plan1="${PLANS_DIR}/$1"
        else
            error "Plan file not found: $1"
        fi

        if [[ -f "$2" ]]; then
            plan2="$2"
        elif [[ -f "${PLANS_DIR}/$2" ]]; then
            plan2="${PLANS_DIR}/$2"
        else
            error "Plan file not found: $2"
        fi
    else
        error "Too many arguments. Usage: tf diff [plan1] [plan2]"
    fi

    local plan1_name plan2_name
    plan1_name=$(basename "$plan1")
    plan2_name=$(basename "$plan2")

    info "Comparing plans:"
    echo -e "  ${CYAN}Newer:${NC}  $plan1_name"
    echo -e "  ${CYAN}Older:${NC}  $plan2_name"
    echo

    # Generate diffs using terraform show
    local diff_output
    diff_output=$(diff -u \
        <(command $TF_CMD show -no-color "$plan2") \
        <(command $TF_CMD show -no-color "$plan1") \
    )

    if [[ -z "$diff_output" ]]; then
        success "Plans are identical"
    else
        # Colorize diff output
        echo "$diff_output" | while IFS= read -r line; do
            if [[ "$line" =~ ^@@  ]]; then
                echo -e "${CYAN}${line}${NC}"
            elif [[ "$line" =~ ^- ]]; then
                echo -e "${RED}${line}${NC}"
            elif [[ "$line" =~ ^\+ ]]; then
                echo -e "${GREEN}${line}${NC}"
            else
                echo "$line"
            fi
        done
    fi
}

# Show current plan metadata
cmd_current() {
    check_terraform_dir

    local latest_plan
    if latest_plan=$(get_latest_plan); then
        local plan_name plan_size plan_date
        plan_name=$(basename "$latest_plan")
        plan_size=$(du -h "$latest_plan" | cut -f1)
        plan_date=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$latest_plan" 2>/dev/null || stat -c "%y" "$latest_plan" 2>/dev/null | cut -d'.' -f1)

        info "Current plan:"
        echo
        echo -e "  ${CYAN}${plan_name}${NC}"
        echo "    Size: $plan_size"
        echo "    Created: $plan_date"
        echo "    Path: $latest_plan"
    else
        error "No saved plan found. Run 'tf plan' first."
    fi
}

# Show plan or state
cmd_show() {
    check_terraform_dir

    # If no arguments, show latest plan
    if [[ $# -eq 0 ]]; then
        local latest_plan
        if latest_plan=$(get_latest_plan); then
            local plan_name
            plan_name=$(basename "$latest_plan")

            info "Showing saved plan: $plan_name"
            echo

            command $TF_CMD show "$latest_plan"
        else
            error "No saved plan found. Run 'tf plan' first."
        fi
        return $?
    fi

    # If argument is provided, determine what to show
    local target="$1"

    # Special case: 'tf show state' explicitly shows state, not plan
    if [[ "$target" == "state" ]]; then
        shift
        command $TF_CMD show "$@"
        return $?
    fi

    # If first arg is a flag (starts with -), apply it to latest plan
    if [[ "$target" == -* ]]; then
        local latest_plan
        if latest_plan=$(get_latest_plan); then
            local plan_name
            plan_name=$(basename "$latest_plan")

            info "Showing saved plan: $plan_name"
            echo

            command $TF_CMD show "$@" "$latest_plan"
        else
            error "No saved plan found. Run 'tf plan' first."
        fi
        return $?
    fi

    shift

    # If it's an existing file, show it
    if [[ -f "$target" ]]; then
        command $TF_CMD show "$target" "$@"
        return $?
    fi

    # If it looks like a plan file (ends with .tfplan), check plans directory
    if [[ "$target" == *.tfplan ]]; then
        local plan_path="${PLANS_DIR}/${target}"
        if [[ -f "$plan_path" ]]; then
            info "Showing saved plan: $target"
            echo
            command $TF_CMD show "$plan_path" "$@"
            return $?
        fi
    fi

    # Otherwise, pass through to terraform show
    command $TF_CMD show "$target" "$@"
}

# Show summary of most recent plan
cmd_summary() {
    check_terraform_dir

    # Try to get the latest plan file
    local latest_plan
    if latest_plan=$(get_latest_plan); then
        local plan_name
        plan_name=$(basename "$latest_plan")

        info "Plan summary: $plan_name"
        echo

        # Get the plan output and extract resource changes (no color for easier parsing)
        local plan_output
        plan_output=$(command $TF_CMD show -no-color "$latest_plan" 2>&1)

        # Strip terragrunt timestamp prefixes (e.g., "11:55:56.132 STDOUT terraform: ")
        # This normalizes output for both terraform and terragrunt
        plan_output=$(echo "$plan_output" | sed 's/^[0-9:.]*[[:space:]]*STDOUT[[:space:]]*terraform:[[:space:]]*//')

        # Extract the summary line (e.g., "Plan: 3 to add, 1 to change, 2 to destroy.")
        local summary
        summary=$(grep -E "^Plan: " <<< "$plan_output" || echo "")

        if [[ -n "$summary" ]]; then
            echo -e "${GREEN}$summary${NC}"
            echo

            # Extract resource addresses by action type
            local resources_to_create resources_to_update resources_to_replace resources_to_destroy

            # Resources to be created (will be created)
            resources_to_create=$(grep "# .* will be created" <<< "$plan_output" | sed 's/.*# \(.*\) will be created/\1/' || echo "")

            # Resources to be updated (will be updated in-place)
            resources_to_update=$(grep "# .* will be updated in-place" <<< "$plan_output" | sed 's/.*# \(.*\) will be updated in-place/\1/' || echo "")

            # Resources to be replaced (must be replaced)
            resources_to_replace=$(grep "# .* must be replaced" <<< "$plan_output" | sed 's/.*# \(.*\) must be replaced/\1/' || echo "")

            # Resources to be destroyed (will be destroyed)
            resources_to_destroy=$(grep "# .* will be destroyed" <<< "$plan_output" | sed 's/.*# \(.*\) will be destroyed/\1/' || echo "")

            # Display resources to be replaced (separate section)
            if [[ -n "$resources_to_replace" ]]; then
                local replace_count
                replace_count=$(echo "$resources_to_replace" | wc -l | xargs)
                echo -e "  ${CYAN}↻${NC} ${replace_count} to replace"

                # Try to detect create_before_destroy vs destroy_before_create
                # Look for the resource declaration lines to see if they're +/- or -/+
                while IFS= read -r resource; do
                    # Escape dots and brackets for grep pattern
                    local pattern
                    pattern=$(echo "$resource" | sed 's/\./\\./g; s/\[/\\[/g; s/\]/\\]/g')

                    # Look for the line after the comment to see the operation order
                    # -/+ means destroy then create, +/- means create then destroy
                    local op_line
                    op_line=$(grep -A1 "# ${pattern} must be replaced" <<< "$plan_output" | tail -1 || echo "")

                    if [[ "$op_line" =~ ^[[:space:]]*\+/- ]]; then
                        echo -e "    ${CYAN}↻${NC} $resource ${GREEN}(create before destroy)${NC}"
                    elif [[ "$op_line" =~ ^[[:space:]]*-/\+ ]]; then
                        echo -e "    ${CYAN}↻${NC} $resource ${YELLOW}(destroy before create)${NC}"
                    else
                        echo -e "    ${CYAN}↻${NC} $resource"
                    fi
                done <<< "$resources_to_replace"
                echo
            fi

            # Display resources to add (pure creates, not replacements)
            if [[ -n "$resources_to_create" ]]; then
                local create_count
                create_count=$(echo "$resources_to_create" | wc -l | xargs)
                echo -e "  ${GREEN}+${NC} ${create_count} to add"
                while IFS= read -r resource; do
                    echo -e "    ${GREEN}+${NC} $resource"
                done <<< "$resources_to_create"
                echo
            fi

            # Display resources to change (in-place updates)
            if [[ -n "$resources_to_update" ]]; then
                local change_count
                change_count=$(echo "$resources_to_update" | wc -l | xargs)
                echo -e "  ${YELLOW}~${NC} ${change_count} to change"
                while IFS= read -r resource; do
                    echo -e "    ${YELLOW}~${NC} $resource"
                done <<< "$resources_to_update"
                echo
            fi

            # Display resources to destroy (pure destroys, not replacements)
            if [[ -n "$resources_to_destroy" ]]; then
                local destroy_count
                destroy_count=$(echo "$resources_to_destroy" | wc -l | xargs)
                echo -e "  ${RED}-${NC} ${destroy_count} to destroy"
                while IFS= read -r resource; do
                    echo -e "    ${RED}-${NC} $resource"
                done <<< "$resources_to_destroy"
            fi
        else
            # Try to detect if there are no changes
            if echo "$plan_output" | grep -q "No changes"; then
                success "✓ No changes. Infrastructure matches the configuration."
            else
                warning "Could not extract plan summary"
                echo
                echo "Run 'tf show' to see the full plan details"
            fi
        fi
    else
        error "No saved plan found. Run 'tf plan' first."
    fi
}

# Show help for tf wrapper
cmd_help() {
    echo -e "${BLUE}tf${NC} - Terraform/Terragrunt wrapper with enhanced plan/apply workflow"
    echo
    echo -e "${CYAN}Current backend:${NC} ${GREEN}${TF_CMD}${NC}"
    echo
    echo -e "${CYAN}Usage:${NC}"
    echo "  tf plan [args]        Save plan to file with timestamp"
    echo "  tf apply [args]       Apply most recent saved plan (or run normally if no plan)"
    echo "                        (Auto-cleans plan files older than 1 day)"
    echo "  tf current            Show current plan metadata (name, size, date, path)"
    echo "  tf diff [p1] [p2]     Compare plans (defaults to latest two)"
    echo "  tf show [target]      Show latest plan, specific plan file, or state"
    echo "  tf summary            Show high-level summary of plan changes with resources"
    echo "  tf list               List saved plan files with details"
    echo "  tf list -n            List saved plan names only"
    echo "  tf clean              Remove old plan files"
    echo "  tf run-all <cmd>      Run terragrunt command across layers (use alone for help)"
    echo "  tf help               Show this help message"
    echo -e "  tf <cmd> [args]       Pass through to ${TF_CMD} (e.g., ${GREEN}tf init${NC}, ${GREEN}tf validate${NC})"
    echo
    echo -e "${CYAN}Backend Selection:${NC}"
    echo "  Automatically uses terragrunt if terragrunt.hcl exists in current directory."
    echo -e "  Force terragrunt with: ${YELLOW}USE_TERRAGRUNT=1${NC}"
    echo
    echo -e "${CYAN}Plan Storage:${NC}"
    echo -e "  Plans are saved to ${YELLOW}.terraform/plans/${NC} with timestamps"
    echo -e "  A ${YELLOW}latest.tfplan${NC} symlink always points to the most recent plan"
    echo
    echo -e "${CYAN}Shell Completion:${NC}"
    echo "  Bash: source /path/to/tf-completion.bash"
    echo "  Zsh:  source /path/to/tf-completion.zsh"
    echo
    echo -e "${CYAN}Note:${NC} For ${TF_CMD}'s built-in help, use ${GREEN}${TF_CMD} --help${NC}"
    echo
}

# Terragrunt run-all command
cmd_run_all() {
    if [[ "$TF_CMD" != "terragrunt" ]]; then
        error "run-all is only available with terragrunt"
    fi

    if [[ $# -eq 0 ]]; then
        echo -e "${CYAN}Usage:${NC} tf run-all <command> [options]"
        echo
        echo -e "${CYAN}Commands:${NC}"
        echo "  init, validate, plan, apply, destroy, output"
        echo
        echo -e "${CYAN}Scope by directory:${NC}"
        echo "  cd acct-popcorn-prod && tf run-all plan     # Only prod account"
        echo "  cd acct-popcorn-prod/us-west-2 && tf run-all plan  # Only prod us-west-2"
        echo
        echo -e "${CYAN}Filter options:${NC}"
        echo "  --terragrunt-include-dir */vpc-*            # Only vpc layers"
        echo "  --terragrunt-exclude-dir */admin            # Skip admin layers"
        echo "  --terragrunt-strict-include                 # Only explicit includes"
        echo
        echo -e "${CYAN}Examples:${NC}"
        echo "  tf run-all plan                             # All layers from cwd"
        echo "  tf run-all plan --terragrunt-include-dir '*/global'  # Only global layers"
        echo "  tf run-all apply --terragrunt-parallelism 2 # Limit parallel runs"
        return 1
    fi

    local subcmd="$1"
    shift

    info "Running terragrunt run-all $subcmd..."
    echo

    command terragrunt run-all "$subcmd" "$@"
}

# Clean old plan files
cmd_clean() {
    if [[ ! -d "$PLANS_DIR" ]]; then
        info "No plans directory found"
        return 0
    fi

    local plans
    plans=$(find "$PLANS_DIR" -name "*.tfplan" -type f 2>/dev/null)

    if [[ -z "$plans" ]]; then
        info "No plans to clean"
        return 0
    fi

    local count
    count=$(echo "$plans" | wc -l | xargs)

    warning "Found $count plan file(s) to remove"
    echo

    while IFS= read -r plan; do
        echo "  $(basename "$plan")"
    done <<< "$plans"

    echo
    read -rp "Remove all plan files? [y/N] " response

    if [[ "$response" =~ ^[Yy]$ ]]; then
        while IFS= read -r plan; do
            rm -f "$plan"
        done <<< "$plans"

        # Remove plans directory if empty
        rmdir "$PLANS_DIR" 2>/dev/null || true

        success "✓ Removed $count plan file(s)"
    else
        echo "Cancelled"
    fi
}

# Main command dispatcher
main() {
    local subcommand="${1:-}"

    # If no arguments, show help
    if [[ -z "$subcommand" ]]; then
        cmd_help
        return 0
    fi

    case "$subcommand" in
        plan)
            shift
            cmd_plan "$@"
            ;;
        apply)
            shift
            cmd_apply "$@"
            ;;
        current)
            cmd_current
            ;;
        diff)
            shift
            cmd_diff "$@"
            ;;
        show)
            shift
            cmd_show "$@"
            ;;
        summary)
            cmd_summary
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        clean)
            cmd_clean
            ;;
        run-all)
            shift
            cmd_run_all "$@"
            ;;
        help)
            cmd_help
            ;;
        *)
            # Pass through to terraform/terragrunt
            command $TF_CMD "$@"
            ;;
    esac
}

main "$@"
